{"title":"Vecteurs et listes","markdown":{"yaml":{"date":"03-06-2024","date-modified":"last-modified","date-format":"ddd D MMM YYYY","author":[{"name":"Roger MARTIN","email":"Roger57que@free.fr"},{"name":"Jenny BRYAN","url":"https://jennybc.github.io/purrr-tutorial/bk00_vectors-and-lists.html"}]},"headingText":"Vecteurs et listes","containsRefs":false,"markdown":"\n\n\n## Vecteurs atomiques\nIl faut savoir que les listes sont des structures de données qui généralisent les vecteurs atomiques. Il faut donc vraiment commencer par là.\n\nL'objet `R` de base est un vecteur atomique comme celui-ci :\n\n```{r}\nv_log <- c(TRUE, FALSE, FALSE, TRUE)\nv_log\n```\n\n::: {.callout-note}\n`R` ne comprend ***QUE*** des vecteurs. Le code ci-dessus affecte à une variable appelée `v_log` un vecteur de $4$ éléments logiques (leurs seules valeurs possibles sont VRAI ou FAUX)[voir @frwiki:vecteur]\n\n[Un point sur les vecteurs.](Aides/vecteurs-en-R.qmd)\n:::\n\nD'autres vecteurs atomiques :\n```{r}\n# vecteur de 4 nombres entiers\n(v_int <- 1:4)\n```\n```{r}\n# vecteur de 4 nombres rationnels\n(v_rat <- 1:4 * 1.25)\n```\n```{r}\n# vecteur de 4 caractères\n(v_car <- letters[1:4])\n```\n\nLes vecteurs atomiques sont homogènes. Chaque élément est du même type, et est un scalaire, c'est à dire « a une longueur un ». Les exemples ci-dessus couvrent les versions les plus courantes des vecteurs `R` (logique, entier, double, caractère), même si vous en rencontrerez éventuellement des plus exotiques.\n\nVous pouvez construire un vecteur « à la main » avec la c()fonction. Nous l'avons utilisé ci-dessus pour construire le vecteur logique. Tous les autres vecteurs sont apparus par d'autres moyens et cela est révélateur de la vie réelle : la plupart des vecteurs ne sont pas créés explicitement avec c(). Ils ont tendance à être créés avec un générateur, comme le 1:nraccourci, ou via la transformation d'un objet existant.\n\n« Indexer un vecteur » signifie adresser des éléments ou des atomes spécifiques, que ce soit pour la lecture ou l'écriture. Nous indexons un vecteur à l’aide de crochets, comme ceci : x[something]. Il existe plusieurs manières d'exprimer les éléments souhaités, c'est-à-dire qu'il existe plusieurs formes valables pour something :\n\nvecteur logique : conserver les éléments de xpour lesquels somethingc'est TRUEet supprimer ceux pour lesquels c'estFALSE\n\nv_char[c(FALSE, FALSE, TRUE, TRUE)]\n#> [1] \"c\" \"d\"\nv_char[v_log]\n#> [1] \"a\" \"d\"\nvecteur entier, tous positifs : les éléments spécifiés dans somethingsont conservés\nentiers négatifs, tous négatifs : les éléments spécifiés dans somethingsont supprimés\n\nv_doub[2:3]\n#> [1] 2.4 3.6\nv_char[-4]\n#> [1] \"a\" \"b\" \"c\"\nvecteur de caractères : suppose qu'il xs'agit d'un vecteur nommé et que les éléments dont les noms sont spécifiés ne somethingsont pas affichés ici, car aucun de nos vecteurs n'est nommé\n\nDes exercices\nQue se passe-t-il lorsque vous demandez le zéro-ème élément de l'un de nos vecteurs ?\nQue se passe-t-il lorsque vous demandez un élément qui dépasse la fin du vecteur, c'est-à-dire x[k]lorsque la longueur de xest inférieure à k?\nNous avons indexé un vecteur xavec un vecteur d'entiers positifs plus court que x. Que se passe-t-il si le vecteur d'indexation est plus long que x?\nNous avons indexé xavec un vecteur logique de même longueur. Que se passe-t-il si le vecteur d'indexation est plus court que x?\nFaites les exercices et vous verrez qu'il est possible d'obtenir un vecteur atomique de longueur nulle et aussi d'obtenir des éléments qui le sont NA. Notez que, dans ces deux scénarios, le type de variable sous-jacent est conservé.\n\nv_int[0]\n#> integer(0)\ntypeof(v_int[0])\n#> [1] \"integer\"\nv_doub[100]\n#> [1] NA\ntypeof(v_doub[100])\n#> [1] \"double\"\nOui, il existe différentes saveurs de NA!\n\n\n\n\n\n\n\n\n\n\n","srcMarkdownNoYaml":"\n\n# Vecteurs et listes\n\n## Vecteurs atomiques\nIl faut savoir que les listes sont des structures de données qui généralisent les vecteurs atomiques. Il faut donc vraiment commencer par là.\n\nL'objet `R` de base est un vecteur atomique comme celui-ci :\n\n```{r}\nv_log <- c(TRUE, FALSE, FALSE, TRUE)\nv_log\n```\n\n::: {.callout-note}\n`R` ne comprend ***QUE*** des vecteurs. Le code ci-dessus affecte à une variable appelée `v_log` un vecteur de $4$ éléments logiques (leurs seules valeurs possibles sont VRAI ou FAUX)[voir @frwiki:vecteur]\n\n[Un point sur les vecteurs.](Aides/vecteurs-en-R.qmd)\n:::\n\nD'autres vecteurs atomiques :\n```{r}\n# vecteur de 4 nombres entiers\n(v_int <- 1:4)\n```\n```{r}\n# vecteur de 4 nombres rationnels\n(v_rat <- 1:4 * 1.25)\n```\n```{r}\n# vecteur de 4 caractères\n(v_car <- letters[1:4])\n```\n\nLes vecteurs atomiques sont homogènes. Chaque élément est du même type, et est un scalaire, c'est à dire « a une longueur un ». Les exemples ci-dessus couvrent les versions les plus courantes des vecteurs `R` (logique, entier, double, caractère), même si vous en rencontrerez éventuellement des plus exotiques.\n\nVous pouvez construire un vecteur « à la main » avec la c()fonction. Nous l'avons utilisé ci-dessus pour construire le vecteur logique. Tous les autres vecteurs sont apparus par d'autres moyens et cela est révélateur de la vie réelle : la plupart des vecteurs ne sont pas créés explicitement avec c(). Ils ont tendance à être créés avec un générateur, comme le 1:nraccourci, ou via la transformation d'un objet existant.\n\n« Indexer un vecteur » signifie adresser des éléments ou des atomes spécifiques, que ce soit pour la lecture ou l'écriture. Nous indexons un vecteur à l’aide de crochets, comme ceci : x[something]. Il existe plusieurs manières d'exprimer les éléments souhaités, c'est-à-dire qu'il existe plusieurs formes valables pour something :\n\nvecteur logique : conserver les éléments de xpour lesquels somethingc'est TRUEet supprimer ceux pour lesquels c'estFALSE\n\nv_char[c(FALSE, FALSE, TRUE, TRUE)]\n#> [1] \"c\" \"d\"\nv_char[v_log]\n#> [1] \"a\" \"d\"\nvecteur entier, tous positifs : les éléments spécifiés dans somethingsont conservés\nentiers négatifs, tous négatifs : les éléments spécifiés dans somethingsont supprimés\n\nv_doub[2:3]\n#> [1] 2.4 3.6\nv_char[-4]\n#> [1] \"a\" \"b\" \"c\"\nvecteur de caractères : suppose qu'il xs'agit d'un vecteur nommé et que les éléments dont les noms sont spécifiés ne somethingsont pas affichés ici, car aucun de nos vecteurs n'est nommé\n\nDes exercices\nQue se passe-t-il lorsque vous demandez le zéro-ème élément de l'un de nos vecteurs ?\nQue se passe-t-il lorsque vous demandez un élément qui dépasse la fin du vecteur, c'est-à-dire x[k]lorsque la longueur de xest inférieure à k?\nNous avons indexé un vecteur xavec un vecteur d'entiers positifs plus court que x. Que se passe-t-il si le vecteur d'indexation est plus long que x?\nNous avons indexé xavec un vecteur logique de même longueur. Que se passe-t-il si le vecteur d'indexation est plus court que x?\nFaites les exercices et vous verrez qu'il est possible d'obtenir un vecteur atomique de longueur nulle et aussi d'obtenir des éléments qui le sont NA. Notez que, dans ces deux scénarios, le type de variable sous-jacent est conservé.\n\nv_int[0]\n#> integer(0)\ntypeof(v_int[0])\n#> [1] \"integer\"\nv_doub[100]\n#> [1] NA\ntypeof(v_doub[100])\n#> [1] \"double\"\nOui, il existe différentes saveurs de NA!\n\n\n\n\n\n\n\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":"fenced","output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"vim-dark","reference-location":"margin","citeproc":true,"output-file":"101-vecteurs-et-listes.html"},"language":{"toc-title-document":"Table des matières","toc-title-website":"Sur cette page","related-formats-title":"Autres formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"La source","other-links-title":"Autres liens","code-links-title":"Liens de code","launch-dev-container-title":"Lancer le Dev Container","launch-binder-title":"Lancer le Binder","article-notebook-label":"Cahier d'articles","notebook-preview-download":"Télécharger le cahier","notebook-preview-download-src":"Télécharger le code source","notebook-preview-back":"Retour à l'article","manuscript-meca-bundle":"Archive MECA","section-title-abstract":"Résumé","section-title-appendices":"Annexes","section-title-footnotes":"Notes de bas de page","section-title-references":"Les références","section-title-reuse":"Réutilisation","section-title-copyright":"Droits d'auteur","section-title-citation":"Citation","appendix-attribution-cite-as":"Veuillez citer ce travail comme suit :","appendix-attribution-bibtex":"BibTeX","title-block-author-single":"Auteur·rice","title-block-author-plural":"Auteur·rice·s","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Date de publication","title-block-modified":"Modifié","title-block-keywords":"Mots clés","callout-tip-title":"Astuce","callout-note-title":"Note","callout-warning-title":"Avertissement","callout-important-title":"Important","callout-caution-title":"Mise en garde","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Montrer tout le code","code-tools-hide-all-code":"Cacher tout le code","code-tools-view-source":"Voir les sources","code-tools-source-code":"Code source","tools-share":"Share","tools-download":"Download","code-line":"Ligne","code-lines":"Lignes","copy-button-tooltip":"Copier vers le presse-papier","copy-button-tooltip-success":"Copié","repo-action-links-edit":"Modifier cette page","repo-action-links-source":"Voir la source","repo-action-links-issue":"Faire part d'un problème","back-to-top":"Retour au sommet","search-no-results-text":"Pas de résultats","search-matching-documents-text":"documents trouvés","search-copy-link-title":"Copier le lien vers la recherche","search-hide-matches-text":"Cacher les correspondances additionnelles","search-more-match-text":"correspondance de plus dans ce document","search-more-matches-text":"correspondances de plus dans ce document","search-clear-button-title":"Effacer","search-text-placeholder":"","search-detached-cancel-button-title":"Annuler","search-submit-button-title":"Envoyer","search-label":"Recherche","toggle-section":"Basculer la section","toggle-sidebar":"Basculer la barre latérale","toggle-dark-mode":"Basculer le mode sombre","toggle-reader-mode":"Basculer en mode lecteur","toggle-navigation":"Basculer la navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Théorème","crossref-lem-title":"Lemme","crossref-cor-title":"Corollaire","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Définition","crossref-exm-title":"Exemple","crossref-exr-title":"Exercice","crossref-ch-prefix":"Chapitre","crossref-apx-prefix":"Annexe","crossref-sec-prefix":"Section","crossref-eq-prefix":"Équation","crossref-lof-title":"Liste des Figures","crossref-lot-title":"Liste des Tables","crossref-lol-title":"Liste des Listings","environment-proof-title":"Preuve","environment-remark-title":"Remarque","environment-solution-title":"Solution","listing-page-order-by":"Trier par","listing-page-order-by-default":"Ordre par défaut","listing-page-order-by-date-asc":"Le plus ancien","listing-page-order-by-date-desc":"Le plus récent","listing-page-order-by-number-desc":"Descendant","listing-page-order-by-number-asc":"Ascendant","listing-page-field-date":"Date","listing-page-field-title":"Titre","listing-page-field-description":"Description","listing-page-field-author":"Auteur·rice","listing-page-field-filename":"Nom de fichier","listing-page-field-filemodified":"Modifié","listing-page-field-subtitle":"Sous-titre","listing-page-field-readingtime":"Temps de lecture","listing-page-field-wordcount":"Compteur de Mots","listing-page-field-categories":"Catégories","listing-page-minutes-compact":"{0} min.","listing-page-category-all":"Tous","listing-page-no-matches":"Aucun article correspondant","listing-page-words":"{0} mots"},"metadata":{"lang":"fr-FR","fig-responsive":true,"quarto-version":"1.4.549","bibliography":["references.bib"],"license":"CC BY-NC-SA","number-depth":3,"theme":"cyborg","fontsize":"1.2em","citations-hover":true,"citation-location":"margin","citation":true,"grid":{"sidebar-width":"200px","body-width":"800px","margin-width":"320px","gutter-width":"0.5rem"},"date":"03-06-2024","date-modified":"last-modified","date-format":"ddd D MMM YYYY","author":[{"name":"Roger MARTIN","email":"Roger57que@free.fr"},{"name":"Jenny BRYAN","url":"https://jennybc.github.io/purrr-tutorial/bk00_vectors-and-lists.html"}]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}