{
  "hash": "dafdc34bea2eabe858e7b4f3901dcab8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate: 03-06-2024\ndate-modified: last-modified\ndate-format: \"ddd D MMM YYYY\"\nauthor:\n  - name: Roger MARTIN\n    email: Roger57que@free.fr\n  - name: Jenny BRYAN\n    url: https://jennybc.github.io/purrr-tutorial/bk00_vectors-and-lists.html\n---\n\n\n# Vecteurs et listes\n\n## Vecteurs atomiques\nIl faut savoir que les listes sont des structures de données qui généralisent les vecteurs atomiques. Il faut donc vraiment commencer par là.\n\nL'objet `R` de base est un vecteur atomique comme celui-ci :\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\nv_log <- c(TRUE, FALSE, FALSE, TRUE)\nv_log\n```\n````\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n::: {.callout-note}\n`R` ne comprend ***QUE*** des vecteurs. Le code ci-dessus affecte à une variable appelée `v_log` un vecteur de $4$ éléments logiques (leurs seules valeurs possibles sont VRAI ou FAUX)[voir @frwiki:vecteur]\n\n[Un point sur les vecteurs.](Aides/vecteurs-en-R.qmd)\n:::\n\nD'autres vecteurs atomiques :\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n# vecteur de 4 nombres entiers\n(v_int <- 1:4)\n```\n````\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n# vecteur de 4 nombres rationnels\n(v_rat <- 1:4 * 1.25)\n```\n````\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.25 2.50 3.75 5.00\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n# vecteur de 4 caractères\n(v_car <- letters[1:4])\n```\n````\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\" \"b\" \"c\" \"d\"\n```\n\n\n:::\n:::\n\n\nLes vecteurs atomiques sont homogènes. Chaque élément est du même type, et est un scalaire, c'est à dire « a une longueur un ». Les exemples ci-dessus couvrent les versions les plus courantes des vecteurs `R` (logique, entier, double, caractère), même si vous en rencontrerez éventuellement des plus exotiques.\n\nVous pouvez construire un vecteur « à la main » avec la c()fonction. Nous l'avons utilisé ci-dessus pour construire le vecteur logique. Tous les autres vecteurs sont apparus par d'autres moyens et cela est révélateur de la vie réelle : la plupart des vecteurs ne sont pas créés explicitement avec c(). Ils ont tendance à être créés avec un générateur, comme le 1:nraccourci, ou via la transformation d'un objet existant.\n\n« Indexer un vecteur » signifie adresser des éléments ou des atomes spécifiques, que ce soit pour la lecture ou l'écriture. Nous indexons un vecteur à l’aide de crochets, comme ceci : x[something]. Il existe plusieurs manières d'exprimer les éléments souhaités, c'est-à-dire qu'il existe plusieurs formes valables pour something :\n\nvecteur logique : conserver les éléments de xpour lesquels somethingc'est TRUEet supprimer ceux pour lesquels c'estFALSE\n\nv_char[c(FALSE, FALSE, TRUE, TRUE)]\n#> [1] \"c\" \"d\"\nv_char[v_log]\n#> [1] \"a\" \"d\"\nvecteur entier, tous positifs : les éléments spécifiés dans somethingsont conservés\nentiers négatifs, tous négatifs : les éléments spécifiés dans somethingsont supprimés\n\nv_doub[2:3]\n#> [1] 2.4 3.6\nv_char[-4]\n#> [1] \"a\" \"b\" \"c\"\nvecteur de caractères : suppose qu'il xs'agit d'un vecteur nommé et que les éléments dont les noms sont spécifiés ne somethingsont pas affichés ici, car aucun de nos vecteurs n'est nommé\n\nDes exercices\nQue se passe-t-il lorsque vous demandez le zéro-ème élément de l'un de nos vecteurs ?\nQue se passe-t-il lorsque vous demandez un élément qui dépasse la fin du vecteur, c'est-à-dire x[k]lorsque la longueur de xest inférieure à k?\nNous avons indexé un vecteur xavec un vecteur d'entiers positifs plus court que x. Que se passe-t-il si le vecteur d'indexation est plus long que x?\nNous avons indexé xavec un vecteur logique de même longueur. Que se passe-t-il si le vecteur d'indexation est plus court que x?\nFaites les exercices et vous verrez qu'il est possible d'obtenir un vecteur atomique de longueur nulle et aussi d'obtenir des éléments qui le sont NA. Notez que, dans ces deux scénarios, le type de variable sous-jacent est conservé.\n\nv_int[0]\n#> integer(0)\ntypeof(v_int[0])\n#> [1] \"integer\"\nv_doub[100]\n#> [1] NA\ntypeof(v_doub[100])\n#> [1] \"double\"\nOui, il existe différentes saveurs de NA!\n\n\n\n\n\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}